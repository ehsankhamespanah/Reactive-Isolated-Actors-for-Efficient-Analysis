\section{Introcution} \label{sec::introduction}

\Marjan{Add your comments in others' sections in color}
\Ehsan{blue}
\Fatem{green}

%Message of the paper: The actor-based language, Rebeca, provides a usable and analyzable model for distributed, concurrent, event-based asynchronous systems (Cyber-Physical systems).

%Distributed systems  are defined like this
%IBM: A distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed system can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. ...distributed system contains multiple nodes that are physically separate but linked together using the network. All the nodes in this system communicate with each other and handle processes in tandem. Each of these nodes contains a small part of the distributed operating system software.

Distributed systems consist of software components executed on different computers that are linked together by a network. The software components communicate with each other in order to achieve the goal of the distributed system.
Nowadays distributed systems are everywhere providing scalability and redundancy.  Design and analysis of such systems is overly challenging.

%Reactive systems are defined like this
%Actor-based languages and distributed systems
Actor model is a model of concurrent computation for developing parallel, distributed and mobile systems \cite{Hewitt:77:Actors,Agha:97:ActorComputation}. Each actor is an autonomous object that operates concurrently, and  send and receive messages asynchronously.
%
Rebeca \cite{DBLP:journals/fuin/SirjaniMSB04,DBLP:conf/fmco/Sirjani06} is an actor-based language proposed to bridge the gap between software engineers and formal methods community.
Rebeca comes with a formal semantics and is the first actor-based language with model checking support \cite{DBLP:journals/csur/BoerSHHRDJSKFY17}.


Models can be used for both synthesis and analysis \cite{DBLP:conf/facs2/LeeS18}. We build abstract models that serve as a specification of a system to be built, and then we refine the models, adding
details until we build the system itself. The process is usually iterative, with
the specifications evolving along with their refinements. We may have different analysis purposes like verification, validation, and performance evaluation. 
Model checking, simulation, and building physical prototypes can all be used as methods for analysis. Simulation, which is the execution of an executable
model, reveals one possible behavior of a model with one set of inputs. Model
checking reveals all possible behaviors of a model over a family of inputs \cite{DBLP:conf/facs2/LeeS18}.
%If we have formal and automatic refinement techniques, we may be able to avoid introducing errors in the refined models while details are added. In this case, synthesis is said to be “correct by construction.”


%Why actors are good models for distributed systems?
%\noindent\textbf{Faithful models for distributed reactive systems} %\label{sec::Faithfulness}
%How models shape the thought and ease the analysis

%From Rocco paper: 
According to De Nicola et.al. in \cite{DBLP:conf/coordination/NicolaFPT18} a major challenge in designing languages is to devise appropriate abstractions and linguistic primitives to deal with the specificities of the domain under investigation.
%
%From Gul and Rajesh: 
%http://web.cs.ucla.edu/~palsberg/course/cs239/papers/karmani-agha.pdfA 
Karmani and Agha believe that a programming language should facilitate the process of writing programs by being close to the conceptual level at which a programmer thinks about a problem, rather than at the level at which it may be implemented \cite{DBLP:reference/parallel/KarmaniA11}. 

In \cite{DBLP:conf/birthday/FriendlinessSirjani18}, Sirjani defines faithfulness as the similarity of the
model and the system; and it is argued that faithfulness can bring in analizability and tracability. 
According to \cite{DBLP:conf/birthday/FriendlinessSirjani18}, a modeling
language is faithful to a system if the model of computation supported by the
language matches the model of computation of [the features of interest of] the
system. 
In \cite{Ptolemy:14:Book} a model of computation (MoC) is defined as a collection of rules that govern
the execution of the [concurrent] components and the communication between
components.
Faithfulness can be seen as the key motivation behind domain-specific
languages.


In the following section we explain what we mean by isolation of actors and how it can help in analysis. We then focus on a model that is presented as the semantics of Timed Rebeca and can help by a significant amount of reduction in the state space while doing the analysis. We believe that similar techniques can be used in different analysis methods for event-based reactive isolated modules. 
%
In Section \ref{sec::DMC}, we present a technique used for analysis by distributed model checking which is specific for actors and Rebeca.
%
Section \ref{sec::wrebeca} explains how we deployed special techniques to make analysis of  mobile adhoc networks possible.

%\noindent\textbf{Analysis of distributed systems and isolated actors.}
\section{Analysis of Distributed Systems and Isolated Actors}
For explaining our approach, we distinguish three levels of abstraction: the distributed software system itself with all the implementation details, the modeling language which is Rebeca here, and the generated state space which is built for the sake of analysis and  we model it as a state transition system. There are alternative ways for analysis, like using logical theorems and applying reasoning based on that, but here we use different variations of state transition systems.
We sometimes call the transition system the semantics of our model as it shows the behavior in a formal way.


Active objects and actors are encapsulated modules with no shared variables. In Rebeca, we also choose to have atomic execution of message servers (i.e. methods, or event handlers) which gives us a macro-step semantics and models a non-preemptive execution of the handlers.
Our actors are reactive, when sending a message they are not blocked and there is no explicit receive. So, there is no coupling via shared variables, no coupling because of waiting for another actor to return a value for a remote procedure call, and no coupling because of a context dependency caused by having a \textit{future}  construct in the language.
This isolation of actors helps in more efficient analysis, and reduces the state space.
Moreover, if we are only interested in the event-based properties we may be able to abstract even more and just keep the states that are followed by a transition which we are interested in. This type of reduction is not straight forward as we need to prove that we are preserving the order of the events while abstracting away some of the states and transitions. 
%This is what is done in partial order reduction.

Floating Time Transition System is a natural event-based semantics for timed actors, giving us a significant amount of reduction in the state space, using a non-trivial novel idea.
	